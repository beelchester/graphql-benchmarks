package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"sync"
	"time"

	"example.com/gqlgen-users/graph/model"
	"github.com/graph-gophers/dataloader"
)

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	resp, err := fetchFromJSONPlaceholder("/users")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var users []*model.User
	if err := decodeResponse(resp, &users); err != nil {
		return nil, err
	}

	return users, nil
}

// dataloader, batch load users
func batchUsers(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
	var results []*dataloader.Result
	//log time taken to batch load batchUsers
	// defer func() {
	// ms := time.Since(time.Now())
	// seconds := ms.Seconds()
	// println("time taken to batch load users in seconds", seconds)
	// }()

	// concurrently fetch batchUsers

	// make requests for each key concurrently

	var wg sync.WaitGroup
	wg.Add(len(keys))

	for _, key := range keys {
		go func(key dataloader.Key) {
			defer wg.Done()
			// println("making request for user", key.String())
			resp, err := fetchFromJSONPlaceholder(fmt.Sprintf("/users/%s", key.String()))
			if err != nil {
				results = append(results, &dataloader.Result{Error: err})
			}
			defer resp.Body.Close()

			var user model.User
			if err := decodeResponse(resp, &user); err != nil {
				results = append(results, &dataloader.Result{Error: err})
			}

			results = append(results, &dataloader.Result{Data: &user})
		}(key)
	}
	wg.Wait()
	return results
}

var userLoader = dataloader.NewBatchedLoader(batchUsers)

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	resp, err := fetchFromJSONPlaceholder("/posts")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var posts []*model.Post

	if err := decodeResponse(resp, &posts); err != nil {
		return nil, err
	}

	// add user to post using dataloader
	var wg sync.WaitGroup
	wg.Add(len(posts))
	for _, post := range posts {
		go func(post *model.Post) {
			defer wg.Done()
			// println("load user", post.UserID)
			user, err := userLoader.Load(ctx, dataloader.StringKey(fmt.Sprintf("%d", post.UserID)))()
			if err != nil {
				return
			}
			post.User = user.(*model.User)
		}(post)
	}
	wg.Wait()

	return posts, nil
}

// Posts is the resolver for the posts field.
func (r *userResolver) Posts(ctx context.Context, obj *model.User) ([]*model.Post, error) {
	resp, err := fetchFromJSONPlaceholder(fmt.Sprintf("/users/%d/posts", obj.ID))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var posts []*model.Post
	if err := decodeResponse(resp, &posts); err != nil {
		return nil, err
	}

	return posts, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var proxyURL = &url.URL{
	Scheme: "http", // or "https" if your proxy is using HTTPS
	Host:   "127.0.0.1:3000",
}
var client = &http.Client{
	Transport: &http.Transport{
		// Proxy: http.ProxyURL(proxyURL),
		MaxIdleConns:        1000, // Set the total max idle connections
		MaxIdleConnsPerHost: 200,  // Set the max idle connections per host
		IdleConnTimeout:     30 * time.Second,
	},
}

func fetchFromJSONPlaceholder(endpoint string) (*http.Response, error) {
	req, err := http.NewRequest("GET", "http://jsonplaceholder.typicode.com"+endpoint, nil)
	if err != nil {
		return nil, err
	}
	return client.Do(req)
}
func decodeResponse(resp *http.Response, v interface{}) error {
	// Use a buffered reader to optimize JSON decoding
	reader := bufio.NewReader(resp.Body)
	return json.NewDecoder(reader).Decode(v)
}
